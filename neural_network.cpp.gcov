        -:    0:Source:neural_network.cpp
        -:    0:Graph:neural_network.gcno
        -:    0:Data:neural_network.gcda
        -:    0:Runs:1
        -:    1:#include <bits/stdc++.h>
        -:    2:
        -:    3:#include <iostream>
        -:    4:
        -:    5:using namespace std;
        -:    6:
        -:    7:vector<float> x = {1.0, 0.7, 1.2};
        -:    8:int lenx = x.size();
        -:    9:vector<vector<float>> w = {{0.5, 1.5, 0.8, 0.9, -1.7, 1.6},
        -:   10:                           {0.8, 0.2, -1.6, 1.2, 2.1, -0.2}};
        -:   11:int lenw = w.size();
        -:   12:
        -:   13:vector<float> _true = {1, 0};
        -:   14:vector<int> loss;
        -:   15:
function _Z18mean_squared_errorSt6vectorIfSaIfEES1_ called 1000 returned 100% blocks executed 100%
     1000:   16:float mean_squared_error(vector<float> y, vector<float> y_pred) {
     1000:   17:    int n = y.size();
call    0 returned 1000
     1000:   18:    float sum = 0;
     3000:   19:    for (int i = 0; i < n; i++) {
branch  0 taken 2000
branch  1 taken 1000 (fallthrough)
     2000:   20:        sum += pow((y[i] - y_pred[i]), 2);
call    0 returned 2000
call    1 returned 2000
call    2 returned 2000
        -:   21:    }
        -:   22:
     1000:   23:    return sum / n;
        -:   24:}
        -:   25:
function main called 1 returned 100% blocks executed 71%
        1:   26:int main() {
        1:   27:    vector<float> layer2;
call    0 returned 1
        1:   28:    vector<float> layer1 = {1};
call    0 returned 1
call    1 returned 1
branch  2 taken 1 (fallthrough)
branch  3 taken 0 (throw)
call    4 returned 1
call    5 never executed
     1001:   29:    for (int iter = 0; iter < 1000; iter++) {
branch  0 taken 1000
branch  1 taken 1 (fallthrough)
     1000:   30:        layer1 = {1};
call    0 returned 1000
branch  1 taken 1000 (fallthrough)
branch  2 taken 0 (throw)
     1000:   31:        layer2 = {};
call    0 returned 1000
branch  1 taken 1000 (fallthrough)
branch  2 taken 0 (throw)
        -:   32:
     3000:   33:        for (int j = 0; j < lenw; j++) {
branch  0 taken 2000
branch  1 taken 1000 (fallthrough)
     2000:   34:            float sum = 0;
     8000:   35:            for (int i = 0; i < lenx; i++) {
branch  0 taken 6000
branch  1 taken 2000 (fallthrough)
     6000:   36:                sum += x[i]*w[j][i];
call    0 returned 6000
call    1 returned 6000
call    2 returned 6000
        -:   37:            }
     2000:   38:            layer1.push_back(1/(1 + exp(-sum)));
call    0 returned 2000
call    1 returned 2000
branch  2 taken 2000 (fallthrough)
branch  3 taken 0 (throw)
        -:   39:        }
        -:   40:
     1000:   41:        int lenlayer1 = layer1.size();
call    0 returned 1000
     3000:   42:        for (int j = 0; j < lenw; j++) {
branch  0 taken 2000
branch  1 taken 1000 (fallthrough)
     2000:   43:            float sum = 0;
     8000:   44:            for (int i = 0; i < lenlayer1; i++) {
branch  0 taken 6000
branch  1 taken 2000 (fallthrough)
     6000:   45:                sum += layer1[i]*w[j][3+i];
call    0 returned 6000
call    1 returned 6000
call    2 returned 6000
        -:   46:            }
     2000:   47:            layer2.push_back(1/1 + exp(-sum));
call    0 returned 2000
call    1 returned 2000
branch  2 taken 2000 (fallthrough)
branch  3 taken 0 (throw)
        -:   48:        }
        -:   49:
     1000:   50:        float del12 = (layer2[0] - _true[0])*layer2[0]*(1-layer2[0]);
call    0 returned 1000
call    1 returned 1000
call    2 returned 1000
call    3 returned 1000
     1000:   51:        float del22 = (layer2[1] - _true[1])*layer2[1]*(1-layer2[1]);
call    0 returned 1000
call    1 returned 1000
call    2 returned 1000
call    3 returned 1000
        -:   52:        
     1000:   53:        float del11 = layer1[1]*(1-layer1[1])*((del12*w[0][3+1])+(del22*w[1][3+1]));
call    0 returned 1000
call    1 returned 1000
call    2 returned 1000
call    3 returned 1000
call    4 returned 1000
call    5 returned 1000
     1000:   54:        float del21 = layer1[2]*(1-layer1[2])*((del12*w[0][3+2])+(del22*w[1][3+2]));
call    0 returned 1000
call    1 returned 1000
call    2 returned 1000
call    3 returned 1000
call    4 returned 1000
call    5 returned 1000
        -:   55:
        -:   56:        vector<vector<float>> delta = {{del11, del21}, 
     3000:   57:                                       {del12, del22}};
call    0 returned 1000
branch  1 taken 1000 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 1000
branch  4 taken 2000 (fallthrough)
branch  5 taken 1000
call    6 returned 2000
call    7 never executed
branch  8 never executed
branch  9 never executed
call   10 never executed
        -:   58:
     3000:   59:        for (int i = 0; i < lenw; i++) {
branch  0 taken 2000
branch  1 taken 1000 (fallthrough)
     4000:   60:            for (int j = 0; j < (int) lenw/2; j++) {
branch  0 taken 2000
branch  1 taken 2000 (fallthrough)
     2000:   61:                w[i][j] -= 0.5*(delta[0][i]*x[j]);
call    0 returned 2000
call    1 returned 2000
call    2 returned 2000
call    3 returned 2000
call    4 returned 2000
        -:   62:            }
        -:   63:        }
        -:   64:
     3000:   65:        for (int i = 0; i < lenw; i++) {
branch  0 taken 2000
branch  1 taken 1000 (fallthrough)
     4000:   66:            for (int j = 0; j < (int) lenw/2; j++) {
branch  0 taken 2000
branch  1 taken 2000 (fallthrough)
     2000:   67:                w[i][3+j] -= 0.5*(delta[1][i]*layer1[j]);
call    0 returned 2000
call    1 returned 2000
call    2 returned 2000
call    3 returned 2000
call    4 returned 2000
        -:   68:            }
        -:   69:        }
        -:   70:
     1000:   71:        float val = mean_squared_error(_true, layer2);
call    0 returned 1000
branch  1 taken 1000 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 1000
branch  4 taken 1000 (fallthrough)
branch  5 taken 0 (throw)
call    6 returned 1000
branch  7 taken 1000 (fallthrough)
branch  8 taken 0 (throw)
call    9 returned 1000
call   10 returned 1000
call   11 never executed
call   12 never executed
        -:   72:
     1000:   73:        loss.push_back(val);
call    0 returned 1000
branch  1 taken 1000 (fallthrough)
branch  2 taken 0 (throw)
     1000:   74:        cout << "**********************************\n";
call    0 returned 1000
branch  1 taken 1000 (fallthrough)
branch  2 taken 0 (throw)
     1000:   75:        cout << "Weight Vector after iteration: " << iter+1 << "\n";
call    0 returned 1000
branch  1 taken 1000 (fallthrough)
branch  2 taken 0 (throw)
call    3 returned 1000
branch  4 taken 1000 (fallthrough)
branch  5 taken 0 (throw)
call    6 returned 1000
branch  7 taken 1000 (fallthrough)
branch  8 taken 0 (throw)
        -:   76:        // cout << w << "\n";
     1000:   77:        cout << "**********************************\n";
call    0 returned 1000
branch  1 taken 1000 (fallthrough)
branch  2 taken 0 (throw)
     1000:   78:    }
call    0 returned 1000
call    1 never executed
        -:   79:
        -:   80:    // cout << layer2 << "\n";
        -:   81:    // cout << loss << "\n";
     2001:   82:}
call    0 returned 1000
call    1 returned 1000
branch  2 taken 1000 (fallthrough)
branch  3 taken 0 (throw)
call    4 returned 1000
call    5 returned 1000
branch  6 taken 1000 (fallthrough)
branch  7 taken 0 (throw)
call    8 returned 1000
call    9 returned 1000
call   10 returned 1000
call   11 returned 1
call   12 returned 1
call   13 never executed
call   14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
call   19 never executed
call   20 never executed
call   21 never executed
